-- 중복 행 제거
SELECT DISTINCT JOB_ID
FROM EMPLOYEES;

-- GROUP BY
-- 조건절 HAVING
SELECT JOB_ID
FROM EMPLOYEES
GROUP BY JOB_ID;

SELECT COUNT(SALARY), SUM(SALARY), SUM(SALARY)/COUNT(SALARY), AVG(SALARY)
FROM EMPLOYEES
WHERE JOB_ID = 'IT_PROG';




/*
NULL 값을 재배치

NVL(대상이 되는 컬럼, 0)
대상이 되는 컬럼 != NULL --> 대상이 되는 컬럼
대상이 되는 컬럼 == NULL --> 0

NVL2(대상이 되는 컬럼, 바꿀값, 0)
대상이 되는 컬럼 != NULL --> 바꿀값
대상이 되는 컬럼 == NULL --> 0

대상이 되는 컬럼값을 바꾸어 표시

*/


SELECT EMPNO, NVL(MGR, 0) MGR
FROM EMP
WHERE DEPTNO = 10;


SELECT EMPNO, NVL2(MGR, 1, 0) MGR
FROM EMP
WHERE DEPTNO = 10;

-- GROUP BY
-- 조건절 HAVING
SELECT JOB_ID, SUM(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID;

SELECT JOB_ID, SUM(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID
HAVING SUM(SALARY)>= 10000;

SELECT DEPARTMENT_ID,JOB_ID,COUNT(SALARY), SUM(SALARY), SUM(SALARY)/COUNT(SALARY), AVG(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID;

SELECT JOB_ID,COUNT(SALARY), SUM(SALARY), SUM(SALARY)/COUNT(SALARY), AVG(SALARY)
FROM EMPLOYEES
WHERE SALARY > 2000
GROUP BY JOB_ID
HAVING SUM(SALARY) > 20000;

/*
OVER(PARTITION BY) 그룹 함수와 연계해서 사용한다.

COUNT (SALARY) OVER(PARTITION BY) == COUNT(') OVER(PARTITION BY)
COUNT(') OVER(PATITION BY)

RANK()
ROW_NUMBER()
DENSE_RANK()

*/

SELECT FIRST_NAME, JOB_ID, SALARY, COUNT(JOB_ID)OVER(PARTITION BY JOB_ID)
FROM EMPLOYEES;

SELECT FIRST_NAME, JOB_ID, SALARY, COUNT(JOB_ID)OVER(PARTITION BY JOB_ID),
    SUM(SALARY)OVER(PARTITION BY JOB_ID),
    SUM(SALARY)OVER(PARTITION BY DEPARTMENT_ID), DEPARTMENT_ID
FROM EMPLOYEES;
--ORDER BY JOB_ID;


