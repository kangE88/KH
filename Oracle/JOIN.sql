/*
JOIN 
여러 개의 테이블에서 원하는 자료를 조회

INNER JOIN 자주 사용된다.
CROSS JOIN 거의 쓸일이 없다.
OUTER JOIN
    ->LEFT OUTER
    ->RIGHT OUTER
    ->FULL OUTER
SELF JOIN
*/

-- INNER JOIN
-- ANSI SQL 
SELECT EMPLOYEE_ID, FIRST_NAME, A.DEPARTMENT_ID, B.DEPARTMENT_ID,
    DEPARTMENT_NAME, LOCATION_ID
FROM EMPLOYEES A INNER JOIN DEPARTMENTS B
    ON A.DEPARTMENT_ID = B.DEPARTMENT_ID
    AND LAST_NAME='King';

-- ORACLE SQL
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, A.DEPARTMENT_ID, B.DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
    AND LAST_NAME='King';



--[[ CROSS JOIN
--ANSI
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.DEPARTMENT_ID,
    B.DEPARTMENT_ID, B.DEPARTMENT_NAME, B.LOCATION_ID
FROM EMPLOYEES A CROSS JOIN DEPARTMENTS B;

--ORACLE
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.DEPARTMENT_ID,
    B.DEPARTMENT_ID, B.DEPARTMENT_NAME, B.LOCATION_ID
FROM EMPLOYEES A, DEPARTMENTS B;

--[[ OUTER JOIN
--ANSI
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.DEPARTMENT_ID, B.DEPARTMENT_ID 
FROM EMPLOYEES A LEFT OUTER JOIN DEPARTMENTS B
    ON A.DEPARTMENT_ID = B.DEPARTMENT_ID;
    
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.DEPARTMENT_ID, B.DEPARTMENT_ID 
FROM EMPLOYEES A LEFT OUTER JOIN DEPARTMENTS B
    ON A.DEPARTMENT_ID = B.DEPARTMENT_ID
WHERE A.DEPARTMENT_ID IS NULL;  
    
--ORACLE
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.DEPARTMENT_ID, B.DEPARTMENT_ID 
FROM EMPLOYEES A, DEPARTMENTS B
    WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID(+);

--RIGHT JOIN
--ORACLE
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.DEPARTMENT_ID, B.DEPARTMENT_ID 
FROM EMPLOYEES A, DEPARTMENTS B
    WHERE A.DEPARTMENT_ID(+) = B.DEPARTMENT_ID;
    
--SELF JOIN 같은 테이블로 JOIN

SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.MANAGER_ID,
    B.EMPLOYEE_ID, B.FIRST_NAME
FROM EMPLOYEES A, EMPLOYEES B
WHERE A.MANAGER_ID = B.EMPLOYEE_ID AND A.JOB_ID ='IT_PROG';

-- 계층구조
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.MANAGER_ID
FROM EMPLOYEES A
    START WITH A.MANAGER_ID IS NOT NULL
    CONNECT BY PRIOR A.MANAGER_ID = A.EMPLOYEE_ID; -- 상향식
    
-- 일반 SELF JOIN
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.SALARY, A.MANAGER_ID,
    B.FIRST_NAME AS MANAGER_NAME
FROM EMPLOYEES A, EMPLOYEES B
WHERE A.MANAGER_ID = B.EMPLOYEE_ID(+)
ORDER BY A.EMPLOYEE_ID;

--상향식
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.SALARY, A.MANAGER_ID,
    B.FIRST_NAME AS MANAGER_NAME
FROM EMPLOYEES A, EMPLOYEES B
WHERE A.MANAGER_ID = B.EMPLOYEE_ID(+)
CONNECT BY PRIOR A.MANAGER_ID = A.EMPLOYEE_ID;

--하향식
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.SALARY, A.MANAGER_ID,
    B.FIRST_NAME AS MANAGER_NAME
FROM EMPLOYEES A, EMPLOYEES B
WHERE A.MANAGER_ID = B.EMPLOYEE_ID(+)
CONNECT BY  A.MANAGER_ID = PRIOR A.EMPLOYEE_ID;


-- 문제1) Steven King의 부서명을 출력하라
SELECT FIRST_NAME, LAST_NAME, B.DEPARTMENT_NAME
FROM EMPLOYEES A INNER JOIN DEPARTMENTS B
    ON A.DEPARTMENT_ID = B.DEPARTMENT_ID
    AND FIRST_NAME='Steven' AND LAST_NAME='King';
    
SELECT A.LAST_NAME, A.FIRST_NAME, B.DEPARTMENT_NAME
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
    AND A.LAST_NAME='King' AND A.FIRST_NAME='Steven';
    
-- 문제2) IT부서에서 근무하고 있는 사람들을 출력하라.
SELECT FIRST_NAME, LAST_NAME, A.DEPARTMENT_ID, B.DEPARTMENT_NAME
FROM EMPLOYEES A INNER JOIN DEPARTMENTS B
ON A.DEPARTMENT_ID = B.DEPARTMENT_ID
AND JOB_ID = 'IT_PROG';

SELECT A.DEPARTMENT_NAME, B.FIRST_NAME, B.LAST_NAME, B.JOB_ID 
FROM DEPARTMENTS A, EMPLOYEES B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
AND A.DEPARTMENT_NAME ='IT';

-- 문제3) EMPLOYEES 테이블과 DEPARTMENTS 테이블을 Cartesian Product(모든 가능한 행들의 Join)하여 사원번호,이름,업무,부서번호,부서명,근무지를 출력하여라.
SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, A.DEPARTMENT_ID,
    B.DEPARTMENT_NAME, LOCATION_ID 
FROM EMPLOYEES A CROSS JOIN DEPARTMENTS B;

SELECT EMPLOYEE_ID, A.LAST_NAME, A.JOB_ID, B.DEPARTMENT_ID, B.DEPARTMENT_NAME, LOCATION_ID
FROM EMPLOYEES A, DEPARTMENTS B;

-- 문제4) EMPLOYEES 테이블에서 사원번호,이름,업무, EMPLOYEES 테이블의 부서번호, DEPARTMENTS 테이블의 부서번호,부서명,근무지를 출력하여라.
SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, A.DEPARTMENT_ID,
    B.DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID
FROM EMPLOYEES A INNER JOIN DEPARTMENTS B
ON A.DEPARTMENT_ID = B.DEPARTMENT_ID;

SELECT A.EMPLOYEE_ID, A.LAST_NAME, A.JOB_ID, A.DEPARTMENT_ID
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID;

-- 문제5) EMPLOYEES 테이블과 DEPARTMENTS 테이블의 부서번호를 조인하고 SA_MAN 사원만의 사원번호,이름,급여,부서명,근무지를 출력하라. (Alias를 사용)
SELECT A.EMPLOYEE_ID, A.LAST_NAME, A.SALARY, 
    B.DEPARTMENT_NAME, B.LOCATION_ID, A.JOB_ID
FROM EMPLOYEES A INNER JOIN DEPARTMENTS B
ON A.DEPARTMENT_ID = B.DEPARTMENT_ID
AND A.JOB_ID = 'SA_MAN';

SELECT B.EMPLOYEE_ID, B.LAST_NAME, B.SALARY, A.DEPARTMENT_NAME, A.LOCATION_ID, B.JOB_ID
FROM DEPARTMENTS A, EMPLOYEES B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
AND B.JOB_ID='SA_MAN';

-- 문제6) EMPLOYEES 테이블과 DEPARTMENTS 테이블에서 DEPARTMENTS 테이블에 있는 모든 자료를 사원번호,이름,업무, 
-- EMPLOYEES 테이블의 부서번호, DEPARTMENTS 테이블의 부서번호,부서명,근무지를 출력하여라

SELECT A.EMPLOYEE_ID, LAST_NAME, JOB_ID,
    B.DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID
FROM EMPLOYEES A INNER JOIN DEPARTMENTS B
--ON B.DEPARTMENT_ID = A.DEPARTMENT_ID;
ON A.DEPARTMENT_ID = B.DEPARTMENT_ID;

SELECT A.EMPLOYEE_ID, LAST_NAME, JOB_ID,
    B.DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID;

SELECT B.EMPLOYEE_ID, B.LAST_NAME, B.JOB_ID, A.DEPARTMENT_ID, B.DEPARTMENT_ID, A.DEPARTMENT_NAME, A.LOCATION_ID 
FROM DEPARTMENTS A, EMPLOYEES B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID(+);


-- 문제7) EMPLOYEES 테이블에서 Self join하여 관리자(매니저)를 출력하여라.
SELECT A.LAST_NAME || '의 관리자는' || B.LAST_NAME || '이다.'
FROM EMPLOYEES A, EMPLOYEES B
WHERE A.MANAGER_ID = B.EMPLOYEE_ID;

--문제8) EMPLOYEES 테이블에서 left join하여 관리자(매니저)를 출력하고 매니저 아이디가 없는 사람은 배제하고 하향식으로 하며, 급여는 역순으로 
-- 출력하라.
SELECT A.LAST_NAME, B.LAST_NAME AS MANAGER_NAME, A.SALARY
FROM EMPLOYEES A LEFT OUTER JOIN EMPLOYEES B
ON A.MANAGER_ID = B.EMPLOYEE_ID
WHERE B.LAST_NAME IS NOT NULL
ORDER BY A.SALARY DESC;

SELECT A.LAST_NAME, B.LAST_NAME AS MANAGER_NAME, A.SALARY 
FROM EMPLOYEES A, EMPLOYEES B
WHERE A.MANAGER_ID = B.EMPLOYEE_ID(+) -- LAFT JOIN
START WITH A.MANAGER_ID IS NOT NULL   -- 매니저 아이디가 없는 사람은 배제
CONNECT BY A.MANAGER_ID = PRIOR A.EMPLOYEE_ID  -- 하향식
ORDER BY A.SALARY DESC; --급여 역순


-- 문제9) EMPLOYEES 테이블에서 right join하여 관리자(매니저)가 108번 // 상향식으로 급여는 역순으로 출력하라.
SELECT A.LAST_NAME, A.MANAGER_ID, A.SALARY,
    B.EMPLOYEE_ID AS MANAGER_ID, B.LAST_NAME AS MANAGER_NAME
FROM EMPLOYEES A RIGHT JOIN EMPLOYEES B
ON A.MANAGER_ID = B.EMPLOYEE_ID
WHERE A.MANAGER_ID = 108
ORDER BY A.MANAGER_ID ASC, A.SALARY DESC;

SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.SALARY, A.MANAGER_ID,
    B.FIRST_NAME AS 매니저명
FROM EMPLOYEES A, EMPLOYEES B
WHERE A.MANAGER_ID(+) = B.EMPLOYEE_ID
AND A.MANAGER_ID = '108'
CONNECT BY PRIOR A.MANAGER_ID = A.EMPLOYEE_ID
ORDER BY A.SALARY DESC;


